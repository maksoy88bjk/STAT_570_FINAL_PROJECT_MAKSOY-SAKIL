---
title: "Evaluation of 3D-var Data Assimilation of WRF Temperature Prediction Over Northwestern Türkiye: A Case Study for the Period of 11 and 16 August, 2004"
author:
  - name: Mehmet AKSOY *(aksoy.mehmet@metu.edu.tr)*
    affiliations:
    - ref: metu
    - ref: civil
  - name: Sercan AKIL  *(sercan.akil@metu.edu.tr)*
    affiliations:
    - ref: metu
    - ref: ggit
affiliations:
  - id: metu
    name: Middle East Technical University, Ankara, Türkiye
  - id: civil
    name: Department of Civil Engineering, Water Resources Lab.
  - id: ggit
    name: Geodetic and Geographic Information Technologies
format:
  pdf:
    toc: true
    lof: true
    lot: true
    number-sections: true
    code-block-bg: "#f8f8f8"	
    cite-method: biblatex
    bibliography: references.bib
    classoption: abstract
    keep-tex: true
abstract: |
  In this project, we have been evaluated temperature prediction of assimilated and non assimilated WRF outputs over Northwestern Türkiye for the period of 11-16 August, 2004. Observation of eleven temperature gauges and corresponding WRF predictions in the study area have been compared. Moreover, predictions were extracted from assimilated and non assimilated raw WRF data of different domains with varied spatio-temporal resolutions by using gauges coordinates. For this purpose, visualization of results and calculation of error proceedings were performed in R programming and Quarto publishing system.
---

::: {style="text-align: justify"}
# Introduction

## Numerical Weather Prediction (NWP) Models

Numerical Weather Prediction (NWP) models are used to predict weather conditions by simulating the atmosphere, oceans, land surface and their interactions. NWP models are based on mathematical equations representing the physical behavior of the atmosphere. These equations are translated into computer code and use governing equations, numerical methods, parameterizations of other physical processes and combined with initial and boundary conditions before running over a geographic area (we call that geographic area as domain). These physical processes need to be approximated in models because of huge simulation computer time which is called as parameterization.

According to ECMWF report, *these processes affect too a small area to be predicted in full detail by NWP models. The major reason lies in the limited computing power that still does not allow us to calculate the all processes for any place on Earth* [@frnda2022].

## Data Assimilation

NWP models start with an initial value and it is the challenge because initial-value effects next predictions with an increasing error. Thus, updating initial-value prediction is a method to improve prediction accuracy which is called as data assimilation. Infrared radiance from the geostationary satellites and on-site radiosonde observation data assimilation are powerful tools to improve the weather forecast have been widely applied with this purpose in the past a few decades [@geer2018].

There are a number of data assimilation techniques used in weather forecasting. One of the most prominent are the three and four dimensional variational data assimilation methods (3D-var and 4D-var). 3D-var incorporates meteorological data only within a time window around the initialization moment and in this method the analysis increment (an increment is introduced due to the actual observations) does not evolve in time, e.g. it has effect only at the beginning of the simulation. On the other hand 4D-var method uses tangent linear and adjoint models which model the propagation of analysis increment and more computing time is needed [@vladimirov2020].

## Weather Research and Forecasting (WRF) model

The Weather Research and Forecasting (WRF) model is a next-generation open source mesoscale numerical weather prediction system. As it is open source, it has a very flexible structure that allows it to be used by met-offices, universities and atmospheric research centers [@powers2017]. The effort to develop WRF began in the latter 1990's and was a collaborative partnership of the National Center for Atmospheric Research (NCAR), the National Oceanic and Atmospheric Administration (NOAA), the U.S. Air Force, the Naval Research Laboratory, the University of Oklahoma, and the Federal Aviation Administration ([WRF web page](https://www.mmm.ucar.edu/models/wrf)).

The WRF model is used for operational weather forecasting and research purposes at *Turkish State Meteorological Service* since last two decades, as it is at many meteorological services around the world. It is the fact that data assimilation of observations into WRF model method is very popular not only in Türkiye but also in all over world since it has a great potential to improve model forecast skill by reducing errors of initial conditions [@yucel2014; @yucel2015; @bao2015; @cheng2017].
:::

::: {style="text-align: justify"}
# Operations on Assimilated WRF Data

There are two files for two different domains as assimilated and non-assimilated predictions of WRF model. Thus, there are four netcdf files totally. We are going to define prediction variables, forecast period and coverage of domains for each file.

## Uploading Necessary Packages

We will need several packages for some implementations in R, for instance; opening of the netcdf files of WRF data, handling of WRF outputs, visualization and similar operations [@readxl; @tidyverse; @ggplot2-2; @ggpubr-2; @raster; @rnaturalearth; @ncdf4; @R.utils; @sf; @gt].

```{r}
#| warning: false
library(readxl)
library(tidyverse)
library(ggplot2)
library(raster)
library(rnaturalearth)
library(ncdf4)
library(R.utils)
library(sf)
library(gt)
library(ggpubr)
```

## Temperature Forecast of WRF in Domain 1

The code in the below reads a NetCDF file (fname) using the *nc_open function* from the ncdf4 package. NetCDF is a file format commonly used for storing multidimensional scientific data including NWP model output.

Firstly, we opened the assimilated WRF output for domain 1. Using sink function the content of WRF output at the attachments ([wrfout_d01_2004-08-11_00_00_00.txt](https://github.com/maksoy88bjk/STAT_570_FINAL_PROJECT_MAKSOY-SAKIL/blob/main/aswout/wrfout_d01_2004-08-11_00_00_00.txt "wrfout_d01_2004-08-11_00_00_00.txt")) can be created. The data cover time and coverage domain information with meteorological predictions such as potential temperature **(T)**, temperature at 2 meter **(T2)**, wind speed at ten meter **(U10 & V10)**, precipitation **(RAINC & RAINNC)** and etc. We need to use name of the variables to extract specific data variables from the raw data.

```{r}
fname <- paste0("D:/Kitaplar/METU-PHD/Thesis/IsmailHocandanAldim_Aksoy_27092023/",
"aswout/wrfout_d01_2004-08-11_00_00_00")
nc_data <- nc_open(fname)

{sink(paste0(fname,".txt"))
  print(nc_data)
  sink()}
```

In the WRF data, air temperature at 2 meter *(the height of observation at gauges)* is available. If 2 meter temperature is not available in netcdf file, the calculation of [Air Temperature Prediction](http://gradsusr.org/pipermail/gradsusr/2011-December/031698.html) from WRF data is described at the given link based on [WRF manual](https://www2.mmm.ucar.edu/wrf/users/docs/user_guide_v4/contents.html). In such a case, *perturbation potential temperature*, *base pressure* and *perturbation pressure* variables has to be extracted to get air temperature prediction.

```         
float T2[west_east,south_north,Time]   
    FieldType: 104
    MemoryOrder: XY 
    description: TEMP at 2 M
    units: K
    stagger: 
    coordinates: XLONG XLAT
```

### Spatial Resolution (Domain 1)

Spatial resolution of domain 1 is 12 km as you can see below *(DX: 12000, DY:12000)*.

```         
78 global attributes:
    TITLE:  OUTPUT FROM WRF V3.1.1 MODEL
    START_DATE: 2004-08-11_00:00:00
    SIMULATION_START_DATE: 2004-08-11_00:00:00
    WEST-EAST_GRID_DIMENSION: 192
    SOUTH-NORTH_GRID_DIMENSION: 116
    BOTTOM-TOP_GRID_DIMENSION: 28
    DX: 12000
    DY: 12000
```

Here, the code extracts specific variables (longitude, latitude, temperature, and time) from the NetCDF file using the *ncvar_get function*.

There are **41** time steps which means we can get predictions along the domain **(191x115)** for whole period. Additionally, the data includes information for **27** layers from bottom to top of the atmosphere. Fortunately, we do not have to deal with upper layers' data since we just need to extract temperature predictions at 2 meters.

```{r}
long<- ncvar_get(nc_data, "XLONG")
lat<- ncvar_get(nc_data, "XLAT", verbose = F)

temp<- ncvar_get(nc_data, "T2") 
dim(temp)
dim(ncvar_get(nc_data, "T"))
```

### Forecast Period & Time Interval (Domain 1)

We can also obtained the forecast horizon by getting time steps from the data. After getting time steps, we see that forecast period is between 11 and 16 (00:00 UTC) August, 2004. In this case, the time interval for the forecast period up to +120 hours *(or five days)* is three hour.

```{r}
t <- ncvar_get(nc_data, "Times"); t
ymd_hms(t[41]) - ymd_hms(t[1])
```

### Study Area (Domain 1)

@fig-domain1 below shows the coverage of domain 1 where covers Türkiye and its surrounding.

The code in the below creates a list of raster objects for each time step from the extracted temperature from raw WRF data set. Kelvin unit has been converted into Celcius by implementing -273.15. Raster objects are used for working with gridded spatial data. Additionally, *ggplot2* package is used to create a map visualization. It overlays the temperature data onto a map of countries, setting up appropriate coordinate systems and color scales.

```{r, fig.width=9,fig.height=5}
#| label: fig-domain1
#| fig-cap: 
#|  Türkiye with its neighboring countries and coverage of domain 1 for assimilated-WRF predictions.

raster_temp<- list()
for (i in 1:dim(temp)[3])   {
    raster_temp[[i]] <- raster(t(temp[, , i] - 273.15), 
       xmn=min(long), xmx=max(long),
       ymn=min(lat), ymx=max(lat), 
       crs=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs+ towgs84=0,0,0"))
}

temp_df <-as.data.frame(raster_temp[[length(t)]], xy = TRUE) 
world <- rnaturalearth::ne_countries(scale='medium',returnclass = 'sf')

ggplot(data = world)  + geom_sf(fill = "white") +
  coord_sf(crs = st_crs(4326), xlim = c(10, 55), ylim = c(30,50)) +
  geom_raster(data = temp_df, aes(x, y, fill = layer), alpha=0.6) +
  scale_fill_viridis_c(limits = c(0, 35)) +
  labs(x="",y="", fill= expression(degree*C)) + 
  ggtitle("Coverage of Domain 1") + theme(legend.key.height = unit(1, "cm"))
```

## Temperature Forecast of WRF in Domain 2

There are **121** time steps for second domain since we can inference by dimension of **T2** data.

```{r}
fname2 <- paste0("D:/Kitaplar/METU-PHD/Thesis/IsmailHocandanAldim_Aksoy_27092023/",
"aswout/wrfout_d02_2004-08-11_00_00_00")
nc_data2 <- nc_open(fname2)

{sink(paste0(fname2,".txt"))
  print(nc_data2)
  sink()}

long_2<- ncvar_get(nc_data2, "XLONG")
lat_2<- ncvar_get(nc_data2, "XLAT", verbose = F)
temp_2<- ncvar_get(nc_data2, "T2") 

dim(temp_2)
```

### Spatial Resolution (Domain 2)

Spatial resolution of domain 2 is 4 km which is a finer resolution than previous one *(DX: 4000, DY: 4000)*.

```         
78 global attributes:
    TITLE:  OUTPUT FROM WRF V3.1.1 MODEL
    START_DATE: 2004-08-11_00:00:00
    SIMULATION_START_DATE: 2004-08-11_00:00:00
    WEST-EAST_GRID_DIMENSION: 133
    SOUTH-NORTH_GRID_DIMENSION: 64
    BOTTOM-TOP_GRID_DIMENSION: 28
    DX: 4000
    DY: 4000
```

### Forecast Period & Time Interval (Domain 2)

Forecast period for domain 2 is same with previous one. However, the time interval is one hour and it has a finer temporal resolution.

```{r}
t2 <- ncvar_get(nc_data2, "Times"); t2
ymd_hms(t2[121]) - ymd_hms(t2[1])
```

### Study Area (Domain 2)

@fig-domain2 below shows the comparison of two domains and coverage of domain 2 where covers some part of northwest of Türkiye.

It is clearly seen that the intersection of domain 1 and 2 is the entire domain 2. Thus, our study area become only the entire domain 2.

```{r, fig.width=9,fig.height=5}
#| warning: false
#| label: fig-domain2
#| fig-cap: Comparison of domain 1 and 2. 

raster_temp_2<- list()
for (i in 1:dim(temp_2)[3])   {
  raster_temp_2[[i]] <- raster(t(temp_2[, , i] - 273.15), 
     xmn=min(long_2), xmx=max(long_2),
     ymn=min(lat_2), ymx=max(lat_2), 
     crs=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs+ towgs84=0,0,0"))
                              }

temp_df_2 <-as.data.frame(raster_temp_2[[length(t2)]], xy = TRUE) 
world <- rnaturalearth::ne_countries(scale='medium',returnclass = 'sf')

ggplot(data = world)  + geom_sf(fill = "white") + 
  coord_sf(crs = st_crs(4326), xlim = c(19, 47.5), ylim = c(33.5,47)) +
  geom_raster(data = temp_df, 
            aes(x, y, fill= layer), alpha=0.3, show.legend = FALSE) + 
  geom_raster(data = temp_df_2, 
            aes(x, y, fill= layer), alpha=0.7, show.legend = FALSE) + 
  scale_fill_viridis_c() + labs(x="",y="") + 
  ggtitle("Coverage of Domain 2") 
```

## Derivation of Temperature Prediction & Observation

### Identification of Meteorological Stations

Domain 2 covers several provinces which are located northwest of Türkiye. Thus, we need to determine meteorological stations for comparing observation versus assimilated and non-assimilated WRF predictions. The code in the chunk reads data from a delimited text file containing information about meteorological stations. Each specific station was selected for each province to evaluate the performance of both assimilated and non-assimilated WRF predictions. @tbl-gauges-domain2 shows the main gauges across the domain 2.

The code uses the *dplyr and gt* packages for data manipulation and table creation. it assist to perform data wrangling and cleaning on the meteorological station data, containing renaming columns, converting province names, and arranging the data. The *tolower function* is used to convert the province names to lowercase. The *str_to_title() function* from the *stringr* package is applied to convert the province names' first letter to title case.

```{r}
#| label: tbl-gauges-domain2
#| tbl-cap: Meteorological stations accross the domain 2.

df_gauges <- read.delim(paste0("D:/Kitaplar/METU-PHD/COURSES/3-TERM/",
"STAT_570/STAT_570_FINAL_PROJECT_MAKSOY-SAKIL/gauges.txt"), sep="|")

df_gauges<- df_gauges[,-c(3,4)]
colnames(df_gauges)<- c("Station","Province","Latitude","Longitude","Altitude") 

df_gauges$Province <- tolower(df_gauges$Province) |> str_to_title() 
df_gauges<- df_gauges |> arrange(Station) 
df_gauges |>  gt()
```

@fig-gauges is shown for distribution of meteorological stations across the study area.

```{r, fig.width=9,fig.height=5}
#| label: fig-gauges
#| fig-cap: Distribution of Meteorological Stations Over Domain 2.
extents<- extent(raster_temp_2[[length(t2)]])

ggplot(data = world)  + geom_sf(fill = "white") + 
  coord_sf(crs = st_crs(4326), xlim = c(extents[1], extents[2]), 
                               ylim = c(extents[3],extents[4])) +
  geom_raster(data = temp_df_2, 
        aes(x, y, fill = layer), alpha=0.6) +
  scale_fill_viridis_c(limits = c(10, 25)) + 
  labs(x="",y="", fill= expression(degree*C)) +
  geom_point(data = df_gauges, aes(x=Longitude, y=Latitude),
             size=3, colour="darkred") + 
  geom_text(data= df_gauges, mapping = aes(x=Longitude, y=Latitude, 
                                           label=Province), nudge_y = -0.1) + 
  ggtitle(paste("Hourly Assimilated WRF Temperature Forecast,", t2[121])) +
  theme(legend.key.width=unit(3,"cm"), legend.position="bottom")
```

### Obtain Temperature Observations

The code reads temperature observations from an excel file. In the raw data, there is no date column but it has multiple columns which are defined for year, month, day and hour information. Therefore, we need to convert them into the single date column by merging them. Then, these columns can be removed by non-selecting. In the raw data set, some dates can be missing;however, these are not defined as null. Therefore, leaping values can be detected then it assigned as a null by using *complete function*.

```{r}
temp_obs<- read_excel(paste0("D:/Kitaplar/METU-PHD/COURSES/3-TERM/",
"STAT_570/STAT_570_FINAL_PROJECT_MAKSOY-SAKIL/",
"df_2023122096C0-Saatlik_Sicaklik.xlsx"))
head(temp_obs)

temp_obs<-
  temp_obs |>
  mutate(date= as.Date(with(temp_obs, paste(YIL,AY,GUN,sep="-")),"%Y-%m-%d")) |>
  mutate(dates= ymd_hms(paste(date, paste(SAAT, 0, 0, sep = ":")), tz="UTC")) |>
  dplyr::select(Istasyon_No, dates, SICAKLIK) |> 
  group_by(Istasyon_No) |> 
  tidyr::complete( dates = seq(ymd_hm("2004-08-10 00:00"), 
                               ymd_hm("2004-08-16 23:00"), by = "1 hours"))

colnames(temp_obs)<- c("Station","dates","observation")
head(temp_obs)

```

### Extraction of Temperature Predictions from WRF

This code stacks raster layers (since time is not constant) and extracts temperature values for meteorological station locations. Gauge locations and prediction values with time need to be combined and data frame columns need to be renamed after extraction procedure. The table below contains three-hour temperature predictions for each province/gauge in domain 1.

```{r}
centroids <- df_gauges[,c(1,3,4)]
coordinates(centroids)= ~ Longitude + Latitude

# domain1
raster_temp_stack<- stack(raster_temp)
raster_temp_value<- raster::extract(raster_temp_stack, centroids)

rt_cpv <- cbind(centroids,raster_temp_value)
rt_cpv_df<- data.frame(rt_cpv)
colnames(rt_cpv_df)
rt_cpv_df<- rt_cpv_df[,-ncol(rt_cpv_df)]
head(rt_cpv_df)[,1:5]

rt_cpv_df<- 
  rt_cpv_df |> 
  dplyr::select(Station, Longitude, Latitude,  everything() )
colnames(rt_cpv_df) <- append(colnames(rt_cpv_df[1:3]),as.character(t))
head(rt_cpv_df)[,1:5]

```

Same procedures applied in previous chunk has to be followed for assimilated data but for domain 2.

```{r}
# domain2
raster_temp_stack_2<- stack(raster_temp_2)
raster_temp_value_2<- raster::extract(raster_temp_stack_2, centroids)

rt_cpv_2 <- cbind(centroids,raster_temp_value_2)
rt_cpv_df_2<- data.frame(rt_cpv_2) 
rt_cpv_df_2<- rt_cpv_df_2[,-ncol(rt_cpv_df_2)]

rt_cpv_df_2<- 
  rt_cpv_df_2 |> 
  dplyr::select(Station, Longitude, Latitude,  everything() )
colnames(rt_cpv_df_2)<- append(colnames(rt_cpv_df_2[1:3]),as.character(t2))
head(rt_cpv_df_2)[,1:5]
```
:::

::: {style="text-align: justify"}
# Operations on Non-Assimilated WRF Data

We need to apply similar procedures on non-assimilated WRF predictions for extraction as shown above.
:::

```{r}
#domain1
fname_nas <- paste0("D:/Kitaplar/METU-PHD/Thesis/IsmailHocandanAldim_Aksoy_27092023/",
"wout/wrfout_d01_2004-08-11_00_00_00")
nc_data_nas <- nc_open(fname_nas)

{sink(paste0(fname_nas,".txt"))
  print(nc_data_nas)
  sink()}

long_nas<- ncvar_get(nc_data_nas, "XLONG")
lat_nas<- ncvar_get(nc_data_nas, "XLAT", verbose = F)
temp_nas<- ncvar_get(nc_data_nas, "T2") 
t_nas <- ncvar_get(nc_data_nas, "Times")

raster_temp_nas<- list()
for (i in 1:dim(temp_nas)[3])   {
    raster_temp_nas[[i]] <- raster(t(temp_nas[, , i] - 273.15), 
       xmn=min(long_nas), xmx=max(long_nas),
       ymn=min(lat_nas), ymx=max(lat_nas), 
       crs=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs+ towgs84=0,0,0"))
}

#domain2
fname2_nas <- paste0("D:/Kitaplar/METU-PHD/Thesis/IsmailHocandanAldim_Aksoy_27092023/",
"wout/wrfout_d02_2004-08-11_00_00_00")
nc_data2_nas <- nc_open(fname2_nas)

{sink(paste0(fname2_nas,".txt"))
  print(nc_data2_nas)
  sink()}

long_2_nas<- ncvar_get(nc_data2_nas, "XLONG")
lat_2_nas<- ncvar_get(nc_data2_nas, "XLAT", verbose = F)
temp_2_nas<- ncvar_get(nc_data2_nas, "T2") 
t2_nas <- ncvar_get(nc_data2_nas, "Times")

raster_temp_2_nas<- list()
for (i in 1:dim(temp_2_nas)[3])   {
    raster_temp_2_nas[[i]] <- raster(t(temp_2_nas[, , i] - 273.15), 
       xmn=min(long_2_nas), xmx=max(long_2_nas),
       ymn=min(lat_2_nas), ymx=max(lat_2_nas), 
       crs=CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs+ towgs84=0,0,0"))
}

# domain1
raster_temp_stack_nas<- stack(raster_temp_nas)
raster_temp_value_nas<- raster::extract(raster_temp_stack_nas, centroids)

rt_cpv_nas <- cbind(centroids,raster_temp_value_nas)
rt_cpv_df_nas<- data.frame(rt_cpv_nas)
rt_cpv_df_nas<- rt_cpv_df_nas[,-ncol(rt_cpv_df_nas)]

rt_cpv_df_nas<- 
  rt_cpv_df_nas |> 
  dplyr::select(Station, Longitude, Latitude,  everything() )
colnames(rt_cpv_df_nas) <- append(colnames(rt_cpv_df_nas[1:3]),as.character(t_nas))

# domain2
raster_temp_stack_2_nas<- stack(raster_temp_2_nas)
raster_temp_value_2_nas<- raster::extract(raster_temp_stack_2_nas, centroids)

rt_cpv_2_nas <- cbind(centroids,raster_temp_value_2_nas)
rt_cpv_df_2_nas<- data.frame(rt_cpv_2_nas) 
rt_cpv_df_2_nas<- rt_cpv_df_2_nas[,-ncol(rt_cpv_df_2_nas)]

rt_cpv_df_2_nas<- 
  rt_cpv_df_2_nas |> 
  dplyr::select(Station, Longitude, Latitude,  everything() )
colnames(rt_cpv_df_2_nas)<- append(colnames(rt_cpv_df_2_nas[1:3]),as.character(t2_nas))

head(rt_cpv_df_2_nas)[,1:5]
```

::: {style="text-align: justify"}
# Results

## Derivation of Data Frames

There are four data frames, including predictions and observations, to represent each domain and assimilation version. However, these data frames are wider format and it is needed to convert them longer since to use them in visualization.

```{r}
# domain1 assimilated prediction: rt_cpv_df
# domain2 assimilated prediction: rt_cpv_df_2

# domain1 non_assimilated prediction: rt_cpv_df_nas
# domain2 non_assimilated prediction: rt_cpv_df_2_nas

# observations: temp_obs

data_list<- list(rt_cpv_df, rt_cpv_df_2, rt_cpv_df_nas, rt_cpv_df_2_nas)
new_df_list<- list()
variable<- c("predict_do1", "predict_do2","predict_do1_nas","predict_do2_nas")
  
for(i in 1:length(variable)){
  new_df_list[[i]] <- 
        data_list[[i]] |> 
        distinct(Station, .keep_all = TRUE) |> 
        pivot_longer(
          cols = starts_with("2004"),
          names_to = "dates",
          values_to = variable[i],
          values_drop_na = FALSE
        ) |> 
        dplyr:: select(Station, dates, variable[i]) # to remove lat long column
      
  new_df_list[[i]]$dates<- str_replace(new_df_list[[i]]$dates, "_"," ")
  new_df_list[[i]]$dates<- ymd_hms(new_df_list[[i]]$dates)

                            }
# domain1: new_df_list[[1]]; new_df_list[[3]]
# domain2: new_df_list[[2]]; head(new_df_list[[4]])

for(i in 1:length(variable)){
new_df_list[[i]] <- 
      new_df_list[[i]] |>        
        left_join(temp_obs, by = c("Station","dates"))
                            }
  
head(new_df_list[[1]]); head(new_df_list[[3]])
head(new_df_list[[2]]); head(new_df_list[[4]])

```

## Visualization

Data frames were manipulated during visualization procedures depend on necessary conditons. For example, non-assimilated *(new_df_list\[\[3\]\])* and assimilated *(new_df_list\[\[1\]\])* predictions for domain 1 are combined with observations while drawing first plot below.

```{r}
#| warning: false
head(
  new_df_list[[1]] |>        
    left_join(new_df_list[[3]], by = c("Station","dates","observation")) )

head(
  new_df_list[[1]] |>        
    left_join(new_df_list[[3]], by = c("Station","dates","observation")) |> 
    pivot_longer(
            cols = -c(1:2),
            names_to = "Temperature",
            values_to = "value",
            values_drop_na = FALSE) )  
```

@fig-do1 is shown for comparison of assimilated and non-assimilated predictions with observations for each gauge *(province)* by three hour intervals, in domain 1. In this plot, each box represent different provinces *(gauges)*, **black** line shows observations, **red** and **blue** lines are for **assimilated** and **non-assimilated** predictions, respectively.

The assimilated and non-assimilated predictions are looks like very similar. Thus, it can be said that data assimilation of temperature prediction in domain 1 has not caused major differences. Moreover, predictions are compatible with observations for some gauges such as Bolu, Kastamonu, Cankırı and etc. However, predictions are not compatible with observations for other gauges such as Sinop, Sakarya, Duzce and Samsun even the flactuations are similar for those gauges.

```{r, fig.width=9,fig.height=5}
#| warning: false
#| label: fig-do1
#| fig-cap: Comparison of predictions with observations for each province in domain 1.

new_df_list[[1]] |>        
  left_join(new_df_list[[3]], by = c("Station","dates","observation")) |> 
  pivot_longer(
          cols = -c(1:2),
          names_to = "Temperature",
          values_to = "value",
          values_drop_na = FALSE) |> 
  mutate(Station = factor(Station, labels = df_gauges$Province )) |>
  mutate(Temperature =  factor(Temperature, 
         levels= c("observation", "predict_do1_nas", "predict_do1")) ) |>  
ggplot(aes(x= dates, y=value)) +   
  geom_line(aes(colour = Temperature), size=0.7) +
  scale_colour_manual(name= expression("Temperature"~(degree*C)), 
          values = c('observation' = "black",
                     'predict_do1_nas' = "#23bfce",
                     'predict_do1' = "#fc2852"),
          labels = c('observation' = 'Observation',
                     'predict_do1_nas' = 'Non-Assimilated Prediction DO1',
                     'predict_do1' = 'Assimilated Prediction DO1')) + 
  theme_bw() + facet_wrap(~Station, scales = "free_y") + 
  labs(x=" ",y=expression("Temperature"~(degree*C))) + 
  theme(axis.text.x = element_text(angle = 0, hjust = 1))  +
  theme(legend.position = c(.88, .1), 
        strip.background = element_rect(colour="black", fill="cornsilk"))

```

@fig-sc1 is shown for scatterplot and heatmap of 3-hour assimilated and non-assimilated predictions versus observations in domain 1. **Red** and **blue** colors represent **assimilated** and **non-assimilated** predictions, respectively, while **black** line shows **fit** of observations versus predictions.

According to the below plots, there is a clear linear relationship for 3-hour assimilated and non-assimilated predictions with observations in domain 1.

```{r, fig.width=9,fig.height=5}
#| warning: false
#| label: fig-sc1
#| fig-cap: Scatterplot and heatmap of observations versus predictions in domain 1.

plot1<- 
  new_df_list[[1]] |>        
    left_join(new_df_list[[3]], by = c("Station","dates","observation")) |> 
      pivot_longer(
        cols = -c(1,2,4),
        names_to = "Pred.Type",
        values_to = "Prediction",
        values_drop_na = FALSE) |>
ggplot(aes(x= observation, y=Prediction, color=Pred.Type)) +   
  theme_bw() +
  geom_point(size=2, alpha=0.5) +   
  geom_smooth(color ="black", se=FALSE) +
  scale_colour_manual(name= " ", 
          values = c('predict_do1_nas' = "blue",
                     'predict_do1' = "#fc2852"),
          labels = c('predict_do1_nas' = 'Non-Assimilated Prediction DO1',
                     'predict_do1' = 'Assimilated Prediction DO1')) +
  labs(x="Observation",y="Prediction") + theme(legend.position = "top")

plot2<- 
  new_df_list[[1]] |>
    left_join(new_df_list[[3]], by = c("Station","dates","observation")) |>
      pivot_longer(
        cols = -c(1,2,4),
        names_to = "Pred.Type",
        values_to = "Prediction",
        values_drop_na = FALSE) |>
ggplot(aes(x= observation, y=Prediction, fill=Pred.Type)) + 
  geom_hex(alpha=0.5) + theme_bw() +
  scale_fill_manual(name= " ",
      values = c('predict_do1_nas' = "blue",
                  'predict_do1' = "red"),
      labels = c('predict_do1_nas' = 'Non-Assimilated Prediction DO1',
                  'predict_do1' = 'Assimilated Prediction DO1')) +
  labs(x="Observation",y="Prediction") + theme(legend.position = "top")

ggarrange(plot1,plot2,ncol=2 ,nrow = 1)
```

@fig-do2 is shown for comparison of hourly assimilated and non-assimilated predictions with observations for each gauge *(province)* in domain 2. In this plot, each box represent different provinces *(gauges)*, **black** line shows observations, **blue** and **red lines** are for **assimilated** and **non-assimilated** predictions, respectively.

The assimilated and non-assimilated predictions are looks like very similar for also in domain 2. Hourly assimilated and non-assimilated predictions are compatible with observations for Bartın, Zonguldak, Kastamonu, Çorum and Samsun provinces but not remained provinces. It is the fact that 3-hour predictions are looking better than hourly ones even though domain 2 has finer resolution in both temporally and spatially. Actually, this result also should be expected since increased resolution may cause rise in error.

```{r, fig.width=9,fig.height=5}
#| warning: false
#| label: fig-do2
#| fig-cap: Comparison of predictions with observations for each province in domain 2.

new_df_list[[2]] |>        
  left_join(new_df_list[[4]], by = c("Station","dates","observation")) |> 
    pivot_longer(
      cols = -c(1:2),
      names_to = "Temperature",
      values_to = "value",
      values_drop_na = FALSE) |> 
  mutate(Station = factor(Station, labels = df_gauges$Province )) |>
  mutate(Temperature =  factor(Temperature, 
         levels= c("observation", "predict_do2_nas", "predict_do2")) ) |>  
ggplot(aes(x= dates, y=value)) +   
  geom_line(aes(colour = Temperature), size=0.7) +
  scale_colour_manual(name= expression("Temperature"~(degree*C)), 
          values = c('observation' = "black",
                     'predict_do2_nas' = "#fc2852",
                     'predict_do2' = "#23bfce"),
          labels = c('observation' = 'Observation',
                     'predict_do2_nas' = 'Non-Assimilated Prediction DO2',
                     'predict_do2' = 'Assimilated Prediction DO2')) + 
  theme_bw() + facet_wrap(~Station, scales = "free_y") + 
  labs(x=" ",y=expression("Temperature"~(degree*C))) + 
  theme(axis.text.x = element_text(angle = 0, hjust = 1))  +
  theme(legend.position = c(.88, .1), 
        strip.background = element_rect(colour="black", fill="cornsilk"))

```

@fig-sc2 is shown for scatterplot and heatmap of 1-hour assimilated and non-assimilated predictions versus observations in domain 2. **Blue** and **red** colors represent **assimilated** and **non-assimilated** predictions, respectively, while **black** line shows **fit** of observations versus predictions.

According to the below plots, there is not a strong relationship between hourly predictions and observations. We think that the reason of this issue is that predictions are so smooth for Sakarya, Bolu, Duzce and Amasya provinces. This situation causes two cluster on the scatterplot and fluctuated fitting line.

```{r, fig.width=9,fig.height=5}
#| warning: false
#| label: fig-sc2
#| fig-cap: Scatterplot and heatmap of observations versus predictions in domain 2.

plot3<- 
new_df_list[[2]] |>        
  left_join(new_df_list[[4]], by = c("Station","dates","observation")) |> 
    pivot_longer(
      cols = -c(1,2,4),
      names_to = "Pred.Type",
      values_to = "Prediction",
      values_drop_na = FALSE) |>
ggplot(aes(x= observation, y=Prediction, color=Pred.Type)) +   
  theme_bw() +
  geom_point(size=2, alpha=0.5) +   
  geom_smooth(color ="black", se=FALSE) +
  scale_colour_manual(name= " ", 
    values = c('predict_do2_nas' = "#fc2852",
               'predict_do2' = "blue"),
    labels = c('predict_do2_nas' = 'Non-Assimilated Prediction DO2',
               'predict_do2' = 'Assimilated Prediction DO2')) +
  labs(x="Observation",y="Prediction") + theme(legend.position = "top")

plot4<- 
new_df_list[[2]] |>
  left_join(new_df_list[[4]], by = c("Station","dates","observation")) |>
    pivot_longer(
       cols = -c(1,2,4),
       names_to = "Pred.Type",
       values_to = "Prediction",
       values_drop_na = FALSE) |>
ggplot(aes(x= observation, y=Prediction, fill=Pred.Type)) + 
  geom_hex(alpha=0.5) +     theme_bw() +
  scale_fill_manual(name= " ",
           values = c('predict_do2_nas' = "#fc2852",
                      'predict_do2' = "blue"),
           labels = c('predict_do2_nas' = 'Non-Assimilated Prediction DO2',
                      'predict_do2' = 'Assimilated Prediction DO2')) +
  labs(x="Observation",y="Prediction") + theme(legend.position = "top")

ggarrange(plot3,plot4,ncol=2 ,nrow = 1)
```

@fig-do1-2 is shown for comparison of three-hour assimilated and non-assimilated predictions with observations for each gauge *(province)* in both two domains. In this plot, each box represent different provinces *(gauges)*, **black** line shows observations, **pink** and **red** lines are for **assimilated** and **non-assimilated** predictions in Domain 1, respectively. Additionally, **blue** and **lighter blue** lines represent **assimilated** and **non-assimilated** predictions in Domain 2, respectively.

This figure is providing us to compare all predictions and observations in same plot for each province/gauge. The predictions in both two domains are compatible except smoothed ones which are mentioned above.

```{r, fig.width=9,fig.height=5}
#| warning: false
#| label: fig-do1-2
#| fig-cap: Comparison of predictions with observations for each province in both two domains.

new_df_list[[1]] |>        
  left_join(new_df_list[[3]], by = c("Station","dates","observation")) |> 
  left_join(new_df_list[[2]], by = c("Station","dates","observation")) |> 
  left_join(new_df_list[[4]], by = c("Station","dates","observation")) |> 
    pivot_longer(
      cols = -c(1,2),
      names_to = "Temperature",
      values_to = "value",
      values_drop_na = FALSE) |> 
  mutate(Station = factor(Station, labels = df_gauges$Province )) |>
  mutate(Temperature =  factor(Temperature, 
         levels= c("observation", "predict_do1", "predict_do1_nas",
                   "predict_do2_nas", "predict_do2")) ) |> 
ggplot(aes(x= dates, y=value)) +   
  geom_line(aes(colour = Temperature), size=0.7) +
  scale_colour_manual(name= expression("Temperature"~(degree*C)), 
          values = c('observation' = "black",
                     'predict_do1_nas' = "#fc2852",
                     'predict_do1' = "#fc95aa",
                     'predict_do2_nas' = "#23bfce",
                     'predict_do2' = "#157882"),
          labels = c('observation' = 'Observation',
                     'predict_do1_nas' = 'Non-Assimilated Prediction DO1',
                     'predict_do1' = 'Assimilated Prediction DO1',
                     'predict_do2_nas' = 'Non-Assimilated Prediction DO2',
                     'predict_do2' = 'Assimilated Prediction DO2')) +
  theme_bw() + 
  facet_wrap(~Station, scales = "free_y") + 
  labs(x=" ",y=expression("Temperature"~(degree*C))) + 
  theme(axis.text.x = element_text(angle = 0, hjust = 1))  +
  theme(legend.position = c(.88, .1), 
        strip.background = element_rect(colour="black", fill="cornsilk"))

```

## Error Analysis

This part calculates various error metrics, including bias, mean squared error (MSE), root mean squared error (RMSE), normalized RMSE (NRMSE), and correlation coefficients for the predictions. @tbl-stats shows the error statistics for both two domains with respect to complete assimilated and non-assimilated predictions.

As an expected result, prediction errors in domain 2 are bigger than domain 1 and correlation coefficient is also worse. Surprisingly, assimilated prediction errors are not less than non-assimilated versions when we compared each domain between among themselves. We think that this situation is also caused smoothed predictions as mentioned previously. Thus, errors for only Kastomunu province which has more appropriate predictions in both domains is given below. Additionally, to examine the opposite of this situation Duzce case is also given below.

```{r}
#| label: tbl-stats
#| tbl-cap: Error statistics of entire predictions in each domain.

#BIAS
bias <- function(x,y) {mean((x-y), na.rm = TRUE)}
#MSE
mse<- function(x,y) {mean((x-y)^2, na.rm = TRUE)}
#RMSE
rmse<- function(x,y) {sqrt( mean( (x-y)^2, na.rm = TRUE) )}
#NRMSE
nrmse<- function(x,y){sqrt( mean((x-y)^2, na.rm = TRUE) ) / (max(x)-min(y))}


# domain1: new_df_list[[1]]; new_df_list[[3]]
# domain2: new_df_list[[2]]; head(new_df_list[[4]])

error_table<- data.frame(
                   Statistics = c("BIAS","MSE","RMSE","NRMSE","COR.COEF"), 
                   Assim_DO1 = 1:5, 
                   Assim_DO2 = 1:5, 
                   Non_Assim_DO1 = 1:5,   
                   Non_Assim_DO2 = 1:5)


for (i in 1:4) {
  error_table[1,i+1] <- bias(as.matrix(new_df_list[[i]][,4]), 
                           as.matrix(new_df_list[[i]][,3]))
  error_table[2,i+1] <- mse(as.matrix(new_df_list[[i]][,4]), 
                           as.matrix(new_df_list[[i]][,3]))
  error_table[3,i+1] <- rmse(as.matrix(new_df_list[[i]][,4]), 
                           as.matrix(new_df_list[[i]][,3]))
  error_table[4,i+1] <- nrmse(as.matrix(new_df_list[[i]][,4]), 
                           as.matrix(new_df_list[[i]][,3]))
  error_table[5,i+1] <- cor(as.matrix(new_df_list[[i]][,4]), 
                           as.matrix(new_df_list[[i]][,3]), use='pairwise.complete.obs')
               }

error_table[,2:5]<- round(error_table[,2:5],4)
error_table |>  gt()

```

@tbl-kastamonu shows the error statistics with respect to assimilated and non-assimilated predictions for **Kastomonu** province in both two domains.

When we investigate the results for only Kastomunu gauge/province assimilated predictions have less errors slightly and better correlation than non-assimilated ones in both two domains.

```{r}
#| label: tbl-kastamonu
#| tbl-cap: Error statistics of predictions for Kastomonu province in each domain.

error_table<- data.frame(
                   Statistics = c("BIAS","MSE","RMSE","NRMSE","COR.COEF"), 
                   Assim_DO1 = 1:5, 
                   Assim_DO2 = 1:5, 
                   Non_Assim_DO1 = 1:5,   
                   Non_Assim_DO2 = 1:5)

for (i in 1:4) {
  kastamonu<- 
      new_df_list[[i]] |> 
        mutate(Station = factor(Station, labels = df_gauges$Province )) |> 
        filter(Station == "Kastamonu" )
    
  error_table[1,i+1] <- bias(as.matrix(kastamonu[,4]), 
                           as.matrix(kastamonu[,3]))
  error_table[2,i+1] <- mse(as.matrix(kastamonu[,4]), 
                           as.matrix(kastamonu[,3]))
  error_table[3,i+1] <- rmse(as.matrix(kastamonu[,4]), 
                           as.matrix(kastamonu[,3]))
  error_table[4,i+1] <- nrmse(as.matrix(kastamonu[,4]), 
                           as.matrix(kastamonu[,3]))
  error_table[5,i+1] <- cor(as.matrix(kastamonu[,4]), 
                           as.matrix(kastamonu[,3]), use='pairwise.complete.obs')
               }

error_table[,2:5]<- round(error_table[,2:5],4)
error_table |>  gt()
```

@tbl-duzce shows the error statistics with respect to assimilated and non-assimilated predictions for **Duzce** province in both two domains. In this example, errors are bigger in assimilated versions and correlation coefficients smaller in domain 2.

```{r}
#| echo: false
#| label: tbl-duzce
#| tbl-cap: Error statistics of predictions for Duzce province in each domain.

error_table<- data.frame(
                   Statistics = c("BIAS","MSE","RMSE","NRMSE","COR.COEF"), 
                   Assim_DO1 = 1:5, 
                   Assim_DO2 = 1:5, 
                   Non_Assim_DO1 = 1:5,   
                   Non_Assim_DO2 = 1:5)

for (i in 1:4) {
  duzce<- 
      new_df_list[[i]] |> 
        mutate(Station = factor(Station, labels = df_gauges$Province )) |> 
        filter(Station == "Duzce" )
    
  error_table[1,i+1] <- bias(as.matrix(duzce[,4]), 
                           as.matrix(duzce[,3]))
  error_table[2,i+1] <- mse(as.matrix(duzce[,4]), 
                           as.matrix(duzce[,3]))
  error_table[3,i+1] <- rmse(as.matrix(duzce[,4]), 
                           as.matrix(duzce[,3]))
  error_table[4,i+1] <- nrmse(as.matrix(duzce[,4]), 
                           as.matrix(duzce[,3]))
  error_table[5,i+1] <- cor(as.matrix(duzce[,4]), 
                           as.matrix(duzce[,3]), use='pairwise.complete.obs')
               }

error_table[,2:5]<- round(error_table[,2:5],4)
error_table |>  gt()
```
:::

::: {style="text-align: justify"}
# Conclusion

The goal of our study was to identify and analyse the effects of data assimilation of WRF predictions over northwestern Türkiye. For this purpose, we compared the both assimilated and non-assimilated WRF temperature predictions with corresponding observations for between 11 and 16 August, 2004. As shown in the result part, for some locations the predictions and observations agree with each other, while rest of them are not in this case. It is not possible to draw definite conclusions about the effects of data assimilation of WRF based on this example alone. More case studies in the same region and in different seasons should be carried out in order to make clearer determinations. However, the integration of the WRF model with data assimilation techniques has proven to be a valuable tool for advancing our understanding of regional weather patterns. The outcomes of this study have practical applications in operational forecasting, research endeavors, and emergency response, contributing to the broader field of atmospheric science.
:::
